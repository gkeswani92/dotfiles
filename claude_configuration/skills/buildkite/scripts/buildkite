#!/usr/bin/env node

const https = require('https');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { exec } = require('child_process');

const API_BASE = 'api.buildkite.com';
const ENV_PATH = path.join(__dirname, '.env');
const TOKEN_URL = 'https://buildkite.com/user/api-access-tokens';

// Load .env file (only local)
function loadEnv() {
  if (fs.existsSync(ENV_PATH)) {
    const content = fs.readFileSync(ENV_PATH, 'utf8');
    for (const line of content.split('\n')) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;
      const match = trimmed.match(/^([^=]+)=(.*)$/);
      if (match) {
        const key = match[1].trim();
        let value = match[2].trim();
        if ((value.startsWith('"') && value.endsWith('"')) ||
            (value.startsWith("'") && value.endsWith("'"))) {
          value = value.slice(1, -1);
        }
        if (!process.env[key] && value) {
          process.env[key] = value;
        }
      }
    }
  }
}

function saveEnv(token) {
  const content = `# Buildkite CLI configuration
# Generated by: buildkite auth

BUILDKITE_TOKEN=${token}
`;
  fs.writeFileSync(ENV_PATH, content, { mode: 0o600 });
}

function openBrowser(url) {
  const cmd = process.platform === 'darwin' ? 'open' :
              process.platform === 'win32' ? 'start' : 'xdg-open';
  exec(`${cmd} "${url}"`);
}

function prompt(question) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  return new Promise(resolve => {
    rl.question(question, answer => {
      rl.close();
      resolve(answer.trim());
    });
  });
}

async function auth() {
  console.log('\nBuildkite CLI Authentication\n');
  console.log('Opening browser to create an API token...');
  console.log('Required scopes: read_builds, read_artifacts, read_pipelines\n');

  openBrowser(TOKEN_URL);

  const token = await prompt('Paste your token here: ');
  if (!token) {
    console.error('Error: No token provided');
    process.exit(1);
  }

  saveEnv(token);
  console.log(`\nCredentials saved to ${ENV_PATH}`);
  console.log('You can now use the buildkite CLI.');
}

loadEnv();

const TOKEN = process.env.BUILDKITE_TOKEN;
const DEFAULT_ORG = process.env.BUILDKITE_ORG;
const DEFAULT_PIPELINE = process.env.BUILDKITE_PIPELINE;

function request(apiPath) {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: API_BASE,
      path: `/v2${apiPath}`,
      headers: {
        Authorization: `Bearer ${TOKEN}`,
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
    };

    https.get(options, (res) => {
      let data = '';
      res.on('data', (chunk) => (data += chunk));
      res.on('end', () => {
        try {
          resolve({ status: res.statusCode, data: JSON.parse(data) });
        } catch {
          resolve({ status: res.statusCode, data });
        }
      });
    }).on('error', reject);
  });
}

function formatState(state) {
  const states = {
    running: 'üîµ running',
    scheduled: '‚è≥ scheduled',
    passed: '‚úÖ passed',
    failed: '‚ùå failed',
    failing: '‚ùå failing',
    blocked: 'üîí blocked',
    canceled: '‚ö™ canceled',
    canceling: '‚ö™ canceling',
    skipped: '‚è≠Ô∏è  skipped',
    not_run: '‚ûñ not run',
    waiting: '‚è≥ waiting',
    waiting_failed: '‚ùå waiting failed',
    broken: 'üíî broken',
    timed_out: '‚è∞ timed out',
  };
  return states[state] || state;
}

function formatDuration(startedAt, finishedAt) {
  if (!startedAt) return '-';
  const start = new Date(startedAt);
  const end = finishedAt ? new Date(finishedAt) : new Date();
  const seconds = Math.floor((end - start) / 1000);
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}m ${s}s`;
}

function formatBytes(bytes) {
  if (!bytes) return '-';
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function formatTime(isoString) {
  if (!isoString) return '-';
  return new Date(isoString).toLocaleString();
}

async function listOrgs() {
  const { status, data } = await request('/organizations');
  if (status !== 200) {
    console.error('Error:', data.message || data);
    return;
  }

  console.log('\nYour Buildkite organizations:\n');
  console.log('SLUG'.padEnd(30), 'NAME');
  console.log('-'.repeat(70));

  for (const org of data) {
    console.log(org.slug.padEnd(30), org.name);
  }
}

async function listPipelines(org) {
  const { status, data } = await request(`/organizations/${org}/pipelines?per_page=50`);
  if (status !== 200) {
    console.error('Error:', data.message || data);
    return;
  }

  console.log(`\nPipelines for ${org}:\n`);
  console.log('SLUG'.padEnd(40), 'NAME');
  console.log('-'.repeat(90));

  for (const pipeline of data) {
    console.log(pipeline.slug.padEnd(40), pipeline.name);
  }
}

async function listBuilds(org, pipeline, limit = 10) {
  const { status, data } = await request(
    `/organizations/${org}/pipelines/${pipeline}/builds?per_page=${limit}`
  );
  if (status !== 200) {
    console.error('Error:', data.message || data);
    return;
  }

  console.log(`\nRecent builds for ${org}/${pipeline}:\n`);
  console.log('#'.padEnd(8), 'BRANCH'.padEnd(30), 'STATE'.padEnd(18), 'DURATION'.padEnd(12), 'CREATED');
  console.log('-'.repeat(100));

  for (const build of data) {
    console.log(
      String(build.number).padEnd(8),
      (build.branch || '-').slice(0, 28).padEnd(30),
      formatState(build.state).padEnd(18),
      formatDuration(build.started_at, build.finished_at).padEnd(12),
      formatTime(build.created_at)
    );
  }
}

async function getBuild(org, pipeline, buildNumber) {
  const { status, data } = await request(
    `/organizations/${org}/pipelines/${pipeline}/builds/${buildNumber}`
  );
  if (status !== 200) {
    console.error('Error:', data.message || data);
    return;
  }

  const b = data;
  console.log(`
Build #${b.number}
Pipeline: ${pipeline}
Branch: ${b.branch}
State: ${formatState(b.state)}
Duration: ${formatDuration(b.started_at, b.finished_at)}
Created: ${formatTime(b.created_at)}
Finished: ${formatTime(b.finished_at)}
Commit: ${b.commit || '-'}
Message: ${b.message || '-'}
Author: ${b.author?.name || b.creator?.name || '-'}
URL: ${b.web_url || '-'}
`);

  if (b.jobs && b.jobs.length > 0) {
    console.log('Jobs:');
    console.log('  ID'.padEnd(40), 'NAME'.padEnd(35), 'STATE');
    console.log('  ' + '-'.repeat(95));

    for (const job of b.jobs) {
      if (job.type === 'script' || job.type === 'command') {
        console.log(
          `  ${job.id}`.padEnd(40),
          (job.name || job.step_key || '-').slice(0, 33).padEnd(35),
          formatState(job.state)
        );
      }
    }
  }
}

async function listJobs(org, pipeline, buildNumber) {
  const { status, data } = await request(
    `/organizations/${org}/pipelines/${pipeline}/builds/${buildNumber}`
  );
  if (status !== 200) {
    console.error('Error:', data.message || data);
    return;
  }

  const jobs = (data.jobs || []).filter(j => j.type === 'script' || j.type === 'command');

  if (jobs.length === 0) {
    console.log('No jobs found');
    return;
  }

  console.log(`\nJobs for build #${buildNumber}:\n`);
  console.log('ID'.padEnd(38), 'NAME'.padEnd(35), 'STATE'.padEnd(18), 'DURATION');
  console.log('-'.repeat(110));

  for (const job of jobs) {
    console.log(
      job.id.padEnd(38),
      (job.name || job.step_key || '-').slice(0, 33).padEnd(35),
      formatState(job.state).padEnd(18),
      formatDuration(job.started_at, job.finished_at)
    );
  }
}

async function getJobLog(org, pipeline, buildNumber, jobId, tail = false) {
  const { status, data } = await request(
    `/organizations/${org}/pipelines/${pipeline}/builds/${buildNumber}/jobs/${jobId}/log`
  );
  if (status !== 200) {
    console.error('Error:', data.message || data);
    return;
  }

  if (!data.content) {
    console.log('Log not available yet. Job may still be in progress.');
    return;
  }

  // Strip ANSI codes for cleaner output
  const cleanLog = data.content.replace(/\x1b\[[0-9;]*m/g, '');

  if (tail) {
    const lines = cleanLog.split('\n');
    console.log(lines.slice(-100).join('\n'));
  } else {
    console.log(cleanLog);
  }
}

async function listArtifacts(org, pipeline, buildNumber, filter) {
  const { status, data } = await request(
    `/organizations/${org}/pipelines/${pipeline}/builds/${buildNumber}/artifacts?per_page=100`
  );
  if (status !== 200) {
    console.error('Error:', data.message || data);
    return;
  }

  let artifacts = data || [];

  if (filter) {
    const regex = new RegExp(filter, 'i');
    artifacts = artifacts.filter(a => regex.test(a.filename) || regex.test(a.path));
  }

  if (artifacts.length === 0) {
    console.log('No artifacts found' + (filter ? ` matching "${filter}"` : ''));
    return;
  }

  console.log(`\nArtifacts for build #${buildNumber}:\n`);
  console.log('FILENAME'.padEnd(50), 'SIZE'.padEnd(12), 'JOB');
  console.log('-'.repeat(100));

  for (const artifact of artifacts) {
    const name = artifact.filename || artifact.path || '-';
    console.log(
      name.slice(0, 48).padEnd(50),
      formatBytes(artifact.file_size).padEnd(12),
      (artifact.job_id || '-').slice(0, 36)
    );
  }

  console.log(`\nTotal: ${artifacts.length} artifact(s)`);
}

async function getArtifactUrl(org, pipeline, buildNumber, filename) {
  const { status, data } = await request(
    `/organizations/${org}/pipelines/${pipeline}/builds/${buildNumber}/artifacts?per_page=100`
  );
  if (status !== 200) {
    console.error('Error:', data.message || data);
    return;
  }

  const artifact = (data || []).find(a =>
    a.filename === filename || a.path === filename || a.filename?.includes(filename)
  );

  if (!artifact) {
    console.error(`Artifact "${filename}" not found`);
    return;
  }

  console.log(artifact.download_url);
}

function usage() {
  console.log(`
buildkite - Query Buildkite build status, jobs, logs, and artifacts

Usage:
  buildkite auth                                  Set up credentials (interactive)
  buildkite orgs                                  List your organizations
  buildkite pipelines [org]                       List pipelines
  buildkite builds [org] [pipeline] [limit]       List recent builds (default: 10)
  buildkite status <build#> [org] [pipeline]      Get build status with jobs
  buildkite jobs <build#> [org] [pipeline]        List jobs for a build
  buildkite log <build#> <job-id> [org] [pipe]    Get job log
  buildkite log --tail <build#> <job-id> [...]    Get last 100 lines
  buildkite artifacts <build#> [org] [pipe] [f]   List artifacts (f=filter)
  buildkite artifact-url <build#> <file> [...]    Get download URL

First time setup:
  Run "buildkite auth" to configure credentials interactively.
  This opens Buildkite in your browser to generate a token.
  Required scopes: read_builds, read_artifacts, read_pipelines

Examples:
  buildkite auth
  buildkite orgs
  buildkite pipelines my-org
  buildkite builds my-org my-pipeline 20
  buildkite status 123
  buildkite jobs 123
  buildkite log 123 abc-def-uuid
  buildkite log --tail 123 abc-def-uuid
  buildkite artifacts 123
  buildkite artifact-url 123 report.html
`);
}

async function main() {
  const args = process.argv.slice(2);
  const cmd = args[0];

  // Auth and help don't require token
  if (cmd === 'auth') {
    await auth();
    return;
  }

  if (!cmd || cmd === 'help' || cmd === '--help' || cmd === '-h') {
    usage();
    return;
  }

  if (!TOKEN) {
    console.error('Error: Not authenticated. Run "buildkite auth" to set up credentials.');
    process.exit(1);
  }

  switch (cmd) {
    case 'orgs':
      await listOrgs();
      break;

    case 'pipelines': {
      const org = args[1] || DEFAULT_ORG;
      if (!org) {
        console.error('Error: Organization required. Use: buildkite pipelines <org>');
        process.exit(1);
      }
      await listPipelines(org);
      break;
    }

    case 'builds': {
      const org = args[1] || DEFAULT_ORG;
      const pipeline = args[2] || DEFAULT_PIPELINE;
      const limit = parseInt(args[3]) || 10;
      if (!org || !pipeline) {
        console.error('Error: Org and pipeline required. Use: buildkite builds <org> <pipeline> [limit]');
        process.exit(1);
      }
      await listBuilds(org, pipeline, limit);
      break;
    }

    case 'status': {
      const buildNumber = args[1];
      const org = args[2] || DEFAULT_ORG;
      const pipeline = args[3] || DEFAULT_PIPELINE;
      if (!buildNumber || !org || !pipeline) {
        console.error('Error: Build number required. Use: buildkite status <build#> [org] [pipeline]');
        process.exit(1);
      }
      await getBuild(org, pipeline, buildNumber);
      break;
    }

    case 'jobs': {
      const buildNumber = args[1];
      const org = args[2] || DEFAULT_ORG;
      const pipeline = args[3] || DEFAULT_PIPELINE;
      if (!buildNumber || !org || !pipeline) {
        console.error('Error: Build number required. Use: buildkite jobs <build#> [org] [pipeline]');
        process.exit(1);
      }
      await listJobs(org, pipeline, buildNumber);
      break;
    }

    case 'log': {
      let tail = false;
      let buildNumber, jobId, org, pipeline;

      if (args[1] === '--tail') {
        tail = true;
        buildNumber = args[2];
        jobId = args[3];
        org = args[4] || DEFAULT_ORG;
        pipeline = args[5] || DEFAULT_PIPELINE;
      } else {
        buildNumber = args[1];
        jobId = args[2];
        org = args[3] || DEFAULT_ORG;
        pipeline = args[4] || DEFAULT_PIPELINE;
      }

      if (!buildNumber || !jobId || !org || !pipeline) {
        console.error('Error: Build number and job ID required. Use: buildkite log <build#> <job-id> [org] [pipeline]');
        process.exit(1);
      }
      await getJobLog(org, pipeline, buildNumber, jobId, tail);
      break;
    }

    case 'artifacts': {
      const buildNumber = args[1];
      const org = args[2] || DEFAULT_ORG;
      const pipeline = args[3] || DEFAULT_PIPELINE;
      const filter = args[4];
      if (!buildNumber || !org || !pipeline) {
        console.error('Error: Build number required. Use: buildkite artifacts <build#> [org] [pipeline] [filter]');
        process.exit(1);
      }
      await listArtifacts(org, pipeline, buildNumber, filter);
      break;
    }

    case 'artifact-url': {
      const buildNumber = args[1];
      const filename = args[2];
      const org = args[3] || DEFAULT_ORG;
      const pipeline = args[4] || DEFAULT_PIPELINE;
      if (!buildNumber || !filename || !org || !pipeline) {
        console.error('Error: Build number and filename required. Use: buildkite artifact-url <build#> <filename> [org] [pipeline]');
        process.exit(1);
      }
      await getArtifactUrl(org, pipeline, buildNumber, filename);
      break;
    }

    default:
      usage();
  }
}

main().catch(console.error);
